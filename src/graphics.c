#include "global.h"
#define STBI_NO_THREAD_LOCALS
#define STB_IMAGE_IMPLEMENTATION
#include <stb_image.h>

struct Vertex
{
	int16_t u, v;
    uint32_t color;
	float x,y,z;
};

void *g_frame_buffer_0;
void *g_frame_buffer_1;
void *g_frame_buffer_2;

void *g_last_frame_buffer;

#define MAX_QUADS 100

static unsigned int __attribute__((aligned(16))) g_draw_list[262144];
static struct Vertex __attribute__((aligned(16))) g_vertex_array[2000 * 2];
static int g_vertex_array_pos = 0;

struct Vertex *g_quad_vertices;
static int g_current_quad = 0;

struct Texture
{
    bool in_use;
    int width;
    int height;
    uint8_t *data;
    int format;
};

struct Font
{
    bool in_use;
    int texture;
    int width, height;
    int length_x, length_y;
};

#define MAX_TEXTURES    32
#define MAX_FONTS       5

struct Texture g_textures[MAX_TEXTURES];
int g_texture_count = 0;

struct Font g_fonts[MAX_FONTS];
int g_font_count = 0;

int g_allocated_graphic_bytes = 0;

#define GU_START()   sceGuStart(GU_DIRECT, g_draw_list); g_vertex_array_pos = 0; g_quad_vertices = g_vertex_array; // printf("GU_START\n");
#define GU_FINISH()  sceKernelDcacheWritebackInvalidateAll(); sceGuFinish(); sceGuSync(0,0); // printf("GU_FINISH\n");
#define GU_DRAW_ARRAY_QUADS()   sceKernelDcacheWritebackInvalidateAll(); sceGumDrawArray(GU_SPRITES, GU_COLOR_8888|GU_TEXTURE_16BIT|GU_VERTEX_32BITF|GU_TRANSFORM_3D, 2 * g_current_quad, NULL, g_quad_vertices); // printf("GU_DRAW_ARRAY_QUADS: %d %d\n", g_current_quad, g_vertex_array_pos);
// #define GU_ALLOC_QUAD_ARRAY()   g_current_quad = 0; g_quad_vertices = (struct Vertex*)sceGuGetMemory(MAX_QUADS * 2 * sizeof(struct Vertex)); // printf("GU_ALLOC_QUAD_ARRAY: %p %p %p %p %p %p\n", g_quad_vertices, (void *)g_draw_list, sceGeEdramGetAddr(), sceGeEdramGetAddr() + (int)g_frame_buffer_0, sceGeEdramGetAddr() + (int)g_frame_buffer_1, sceGeEdramGetAddr() + (int)g_frame_buffer_2);
#define GU_ALLOC_QUAD_ARRAY()   g_vertex_array_pos += g_current_quad * 2; g_quad_vertices = &(g_vertex_array[g_vertex_array_pos]); g_current_quad = 0; // printf("GU_ALLOC_QUAD_ARRAY %d\n", g_vertex_array_pos);

#define FONT_SMALL_WIDTH    6
#define FONT_SMALL_HEIGHT   8
const unsigned char font_small_data[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x0F, 0xC0, 0x00, 0x00, 0x00,
    0x01, 0xC7, 0x00, 0x01, 0xC0, 0x00, 0xFC, 0x0F, 0xDC, 0x71, 0xC0, 0x00,
    0x02, 0x2A, 0x94, 0x21, 0xC2, 0x0C, 0xCD, 0xC8, 0xE2, 0x30, 0xC7, 0xAA,
    0x03, 0x6F, 0xBE, 0x73, 0xE7, 0x1E, 0x86, 0x27, 0x62, 0x51, 0x47, 0x9C,
    0x02, 0xA8, 0xBE, 0xFB, 0x6F, 0x9E, 0x86, 0x27, 0x48, 0x8A, 0x24, 0xB6,
    0x03, 0x6D, 0x9C, 0x70, 0x8D, 0x8C, 0xCE, 0x27, 0x5C, 0x8A, 0xAD, 0x9C,
    0x01, 0xC7, 0x08, 0x21, 0xC2, 0x00, 0xFD, 0xC8, 0xC8, 0x71, 0xCD, 0xAA,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x0F, 0xC0, 0x00, 0x80, 0x00,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x07, 0x14, 0x79, 0xC0, 0x1C, 0x21, 0xC0, 0x00, 0x01, 0x40, 0x3E,
    0xC0, 0x6F, 0x94, 0xAA, 0x00, 0x3E, 0x71, 0xC2, 0x08, 0x03, 0x60, 0x3E,
    0xE0, 0xE2, 0x14, 0xAB, 0xE0, 0x08, 0xF9, 0xCF, 0x1E, 0x83, 0xE2, 0x1C,
    0xF1, 0xE2, 0x14, 0x6B, 0xE0, 0x3E, 0x73, 0xEF, 0xBE, 0x83, 0x67, 0x08,
    0xE0, 0xEF, 0x80, 0x28, 0x2F, 0x9C, 0x71, 0xCF, 0x1E, 0xF9, 0x4F, 0x80,
    0xC0, 0x67, 0x14, 0x29, 0xCF, 0x88, 0x70, 0x82, 0x08, 0x00, 0x0F, 0x80,
    0x00, 0x02, 0x00, 0x00, 0x00, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x8D, 0x94, 0x23, 0x26, 0x0C, 0x31, 0x8A, 0x80, 0x00, 0x00, 0x02,
    0x01, 0x8D, 0xBE, 0x7B, 0x69, 0x0C, 0x60, 0xC7, 0x08, 0x00, 0x00, 0x06,
    0x01, 0x85, 0x14, 0xA0, 0xC6, 0x18, 0x40, 0x4F, 0x9C, 0x03, 0xE0, 0x0C,
    0x00, 0x00, 0x3E, 0xF9, 0x8B, 0x80, 0x40, 0x47, 0x08, 0x00, 0x00, 0x18,
    0x01, 0x80, 0x14, 0x2B, 0x69, 0x00, 0x60, 0xCA, 0x80, 0x30, 0x03, 0x30,
    0x01, 0x80, 0x00, 0xF2, 0x66, 0x80, 0x31, 0x80, 0x00, 0x30, 0x03, 0x20,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x70, 0x47, 0x1C, 0x33, 0xE7, 0x3E, 0x71, 0xC0, 0x00, 0x00, 0x00, 0x1C,
    0x88, 0xC8, 0xA2, 0x52, 0x08, 0x02, 0x8A, 0x23, 0x0C, 0x30, 0x06, 0x22,
    0x99, 0x40, 0x8C, 0x91, 0xCF, 0x04, 0x72, 0x23, 0x0C, 0x63, 0xE3, 0x02,
    0xA8, 0x47, 0x02, 0xF8, 0x28, 0x88, 0x89, 0xE0, 0x00, 0xC0, 0x01, 0x8C,
    0xC8, 0x48, 0x22, 0x12, 0x28, 0x88, 0x88, 0x23, 0x0C, 0x63, 0xE3, 0x00,
    0x70, 0x4F, 0x9C, 0x11, 0xC7, 0x08, 0x71, 0xC3, 0x0C, 0x30, 0x06, 0x08,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x71, 0xCF, 0x1C, 0xF3, 0xEF, 0x9C, 0x89, 0xCF, 0x22, 0x82, 0x28, 0x9C,
    0x8A, 0x28, 0xA2, 0x8A, 0x08, 0x22, 0x88, 0x81, 0x24, 0x83, 0x6C, 0xA2,
    0xBA, 0x2F, 0x20, 0x8B, 0x8E, 0x20, 0xF8, 0x81, 0x38, 0x82, 0xAA, 0xA2,
    0xBB, 0xE8, 0xA0, 0x8A, 0x08, 0x26, 0x88, 0x81, 0x24, 0x82, 0x29, 0xA2,
    0x82, 0x28, 0xA2, 0x8A, 0x08, 0x22, 0x88, 0x89, 0x22, 0x82, 0x28, 0xA2,
    0x72, 0x2F, 0x1C, 0xF3, 0xE8, 0x1C, 0x89, 0xC6, 0x22, 0xFA, 0x28, 0x9C,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
    0xF1, 0xCF, 0x1C, 0xFA, 0x28, 0xA2, 0x8A, 0x2F, 0x9C, 0x81, 0xC7, 0x00,
    0x8A, 0x28, 0xA0, 0x22, 0x28, 0xA2, 0x51, 0x41, 0x10, 0xC0, 0x4D, 0x80,
    0x8A, 0x28, 0x9C, 0x22, 0x28, 0xA2, 0x20, 0x82, 0x10, 0x60, 0x40, 0x00,
    0xF2, 0x2F, 0x02, 0x22, 0x28, 0xAA, 0x50, 0x84, 0x10, 0x30, 0x40, 0x00,
    0x82, 0x49, 0x22, 0x22, 0x25, 0x36, 0x88, 0x88, 0x10, 0x18, 0x40, 0x00,
    0x81, 0xA8, 0x9C, 0x21, 0xC2, 0x22, 0x88, 0x8F, 0x9C, 0x09, 0xC0, 0x3E,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x60, 0x08, 0x00, 0x08, 0x03, 0x00, 0x80, 0x82, 0x20, 0x40, 0x00, 0x00,
    0x31, 0xCF, 0x1C, 0x79, 0xC4, 0x9E, 0xB0, 0x00, 0x26, 0x43, 0x4B, 0x1C,
    0x02, 0x28, 0xA2, 0x8A, 0x24, 0x22, 0xC9, 0x86, 0x28, 0x42, 0xAC, 0xA2,
    0x01, 0xE8, 0xA0, 0x8B, 0xE7, 0x3E, 0x88, 0x82, 0x38, 0x42, 0xA8, 0xA2,
    0x02, 0x28, 0xA2, 0x8A, 0x04, 0x02, 0x88, 0x8A, 0x24, 0x42, 0xA8, 0xA2,
    0x03, 0xEF, 0x1C, 0x79, 0xC4, 0x1C, 0x88, 0x84, 0x22, 0x32, 0xA8, 0x9C,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x21, 0x86, 0x80,
    0xB1, 0xEB, 0x0E, 0xE2, 0x28, 0xA2, 0x8A, 0x2F, 0x88, 0x20, 0x8F, 0x88,
    0xCA, 0x2C, 0x90, 0x42, 0x28, 0xA2, 0x52, 0x20, 0x90, 0x00, 0x49, 0x14,
    0x8A, 0x28, 0x0C, 0x42, 0x28, 0xAA, 0x21, 0xE7, 0x10, 0x00, 0x40, 0x22,
    0xF9, 0xE8, 0x22, 0x52, 0x25, 0x36, 0x50, 0x48, 0x08, 0x20, 0x80, 0x22,
    0x80, 0x28, 0x1C, 0x21, 0xC2, 0x22, 0x89, 0x8F, 0x8C, 0x21, 0x80, 0x3E,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0x41, 0x08, 0x51, 0x07, 0x00, 0x21, 0x44, 0x14, 0x21, 0x05, 0x1C,
    0x70, 0x02, 0x14, 0x00, 0x85, 0x00, 0x50, 0x02, 0x00, 0x50, 0x80, 0x14,
    0x88, 0x07, 0x1C, 0x71, 0xC7, 0x1C, 0x71, 0xC7, 0x00, 0x00, 0x07, 0x1C,
    0x82, 0x28, 0xA2, 0x8A, 0x28, 0xA2, 0x8A, 0x28, 0x98, 0x61, 0x88, 0xA2,
    0x8A, 0x2F, 0x9E, 0x79, 0xE7, 0xA0, 0xFB, 0xEF, 0x88, 0x20, 0x88, 0xA2,
    0x72, 0x28, 0x22, 0x8A, 0x28, 0x9E, 0x82, 0x08, 0x08, 0x20, 0x8F, 0xBE,
    0xF1, 0xC7, 0x3E, 0xFB, 0xEF, 0xBC, 0x71, 0xC7, 0x08, 0x20, 0x88, 0xA2,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x20, 0x00, 0x08, 0x41, 0x42, 0x10, 0x01, 0x45, 0x00, 0x00, 0x00, 0x00,
    0x40, 0x07, 0x94, 0x20, 0x05, 0x08, 0x50, 0x00, 0x08, 0x32, 0x2E, 0x0C,
    0xFB, 0x4A, 0x00, 0x00, 0x00, 0x00, 0x01, 0xC8, 0x9C, 0x49, 0x4A, 0x0A,
    0x80, 0xAA, 0x1C, 0x71, 0xC8, 0xA2, 0x8A, 0x28, 0xA0, 0x43, 0xED, 0x08,
    0xE3, 0xEF, 0x22, 0x8A, 0x28, 0xA2, 0x7A, 0x28, 0xA0, 0x70, 0x8B, 0x9C,
    0x82, 0x8A, 0x22, 0x8A, 0x28, 0xA2, 0x0A, 0x28, 0x9C, 0x83, 0xE9, 0x28,
    0xFB, 0xCB, 0x9C, 0x71, 0xC7, 0x1C, 0x71, 0xC7, 0x08, 0xF8, 0x89, 0x98,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x81, 0x04, 0x6B, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x21, 0x02, 0x08, 0xB0, 0xC6, 0x18, 0x20, 0x00, 0x24, 0x91, 0x80, 0x00,
    0x70, 0x00, 0x00, 0x02, 0x29, 0x24, 0x00, 0x00, 0x28, 0xA1, 0x82, 0xA8,
    0x89, 0x87, 0x22, 0xB3, 0x27, 0x98, 0x61, 0xEF, 0x16, 0x58, 0x05, 0x14,
    0x78, 0x88, 0xA2, 0xCA, 0xA0, 0x00, 0x81, 0x01, 0x22, 0xA9, 0x8A, 0x0A,
    0x88, 0x88, 0xA2, 0x8A, 0x6F, 0xBE, 0x89, 0x01, 0x0C, 0x39, 0x85, 0x14,
    0xF8, 0x87, 0x1C, 0x8A, 0x20, 0x00, 0x70, 0x00, 0x0E, 0x09, 0x82, 0xA8,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x4A, 0xAB, 0x4C, 0x30, 0xC6, 0x80, 0x01, 0xA6, 0x80, 0x69, 0xA3, 0x00,
    0x91, 0x56, 0xCC, 0x30, 0xC5, 0x80, 0x01, 0x65, 0x80, 0x59, 0x63, 0x00,
    0x26, 0xAD, 0x8C, 0x33, 0xC6, 0x80, 0xF3, 0xA6, 0xBE, 0xE9, 0xAF, 0x00,
    0x49, 0x5B, 0x4C, 0xF2, 0xCD, 0xBE, 0x51, 0x65, 0x96, 0x5B, 0x65, 0x3C,
    0x92, 0xA6, 0xCC, 0xF1, 0x4E, 0xBA, 0xB2, 0xA6, 0xAA, 0xAB, 0xEB, 0x3C,
    0x25, 0x5D, 0x8C, 0x33, 0xC5, 0x96, 0xF3, 0x65, 0xB6, 0xF8, 0x0F, 0x0C,
    0x4A, 0xAB, 0x4C, 0x30, 0xC6, 0x9A, 0x31, 0xA6, 0x9A, 0x00, 0x00, 0x0C,
    0x91, 0x56, 0xCC, 0x30, 0xC5, 0x96, 0x31, 0x65, 0x96, 0x00, 0x00, 0x0C,
    0x30, 0xC0, 0x0C, 0x00, 0xC3, 0x1A, 0x68, 0x06, 0x80, 0x68, 0x06, 0x80,
    0x30, 0xC0, 0x0C, 0x00, 0xC3, 0x16, 0x58, 0x05, 0x80, 0x58, 0x05, 0x80,
    0x30, 0xC0, 0x0C, 0x00, 0xC3, 0xDA, 0x6D, 0xFE, 0xFF, 0x6F, 0xFE, 0xFF,
    0x3F, 0xFF, 0xCF, 0xFF, 0xF3, 0x57, 0x55, 0x55, 0x55, 0x55, 0x55, 0x55,
    0x3F, 0xFF, 0xCF, 0xFF, 0xF2, 0x9B, 0x69, 0xAA, 0xAA, 0x6A, 0xAA, 0xAA,
    0x00, 0x03, 0x0C, 0x00, 0xC3, 0xD6, 0x7D, 0x7F, 0xF7, 0x5F, 0xFD, 0xFF,
    0x00, 0x03, 0x0C, 0x00, 0xC3, 0x1A, 0x01, 0xA0, 0x1A, 0x68, 0x06, 0x80,
    0x00, 0x03, 0x0C, 0x00, 0xC3, 0x16, 0x01, 0x60, 0x16, 0x58, 0x05, 0x80,
    0x68, 0x00, 0x1A, 0x30, 0x00, 0x1A, 0x30, 0xC0, 0x3F, 0x03, 0x81, 0xFF,
    0x58, 0x00, 0x16, 0x30, 0x00, 0x16, 0x30, 0xC0, 0x3F, 0x03, 0x81, 0xFF,
    0x6B, 0xF0, 0x1A, 0x3C, 0xF0, 0x1A, 0xFC, 0xC0, 0x3F, 0x03, 0x81, 0xFF,
    0xDD, 0x5F, 0xD7, 0x34, 0xD7, 0xF7, 0x57, 0xC3, 0xFF, 0x03, 0x81, 0xFF,
    0xFE, 0xAE, 0xDF, 0x28, 0xA6, 0xFB, 0xAB, 0xC3, 0xFF, 0xFF, 0x81, 0xC0,
    0x03, 0xF5, 0x80, 0x3C, 0xF5, 0x96, 0xFC, 0x03, 0x3F, 0xFF, 0x81, 0xC0,
    0x00, 0xC6, 0x80, 0x00, 0xC6, 0x9A, 0x30, 0x03, 0x3F, 0xFF, 0x81, 0xC0,
    0x00, 0xC5, 0x80, 0x00, 0xC5, 0x96, 0x00, 0x03, 0x3F, 0xFF, 0x81, 0xC0,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x01, 0xEF, 0x80, 0xF8, 0x20, 0x00, 0xF8, 0xC7, 0x0C, 0x00, 0xD0, 0x1C,
    0x69, 0x28, 0xBE, 0x89, 0xC9, 0x1A, 0x71, 0x28, 0x90, 0x51, 0x23, 0xA2,
    0x91, 0x48, 0x14, 0x42, 0x29, 0x2C, 0x89, 0x28, 0x9C, 0xA9, 0x64, 0x22,
    0x91, 0x28, 0x14, 0x42, 0x29, 0x08, 0x89, 0xE8, 0xA2, 0xA9, 0xA7, 0xA2,
    0x91, 0x68, 0x14, 0x8A, 0x2E, 0x88, 0x71, 0x25, 0x22, 0x53, 0x24, 0x22,
    0x69, 0x08, 0x12, 0xF9, 0xC8, 0x04, 0xF8, 0xCD, 0x9C, 0x00, 0xC3, 0xA2,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x83, 0x0C, 0x18, 0xC2, 0x1A, 0xA0, 0x00, 0x06, 0xC3, 0x80, 0x00,
    0xF9, 0xC6, 0x06, 0x3C, 0xC0, 0x2C, 0xE0, 0x00, 0x04, 0xA1, 0x8E, 0x00,
    0x00, 0x8C, 0x03, 0x34, 0xCF, 0x80, 0x00, 0xC0, 0x34, 0xA2, 0x0E, 0x00,
    0xF8, 0x06, 0x06, 0x32, 0xC0, 0x1A, 0x00, 0xC3, 0x14, 0xA3, 0x8E, 0x00,
    0x01, 0xC3, 0x0C, 0x33, 0xC2, 0x2C, 0x00, 0x00, 0x0C, 0x00, 0x0E, 0x00,
    0xF8, 0x0F, 0x9F, 0x31, 0x80, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

#define FONT_BIG_WIDTH    8
#define FONT_BIG_HEIGHT   8
const unsigned char font_big_data[] = {
    0x00, 0x7E, 0x7E, 0x6C, 0x10, 0x38, 0x10, 0x00, 0xFF, 0x00, 0xFF, 0x0F,
    0x3C, 0x3F, 0x3F, 0x18, 0x00, 0x81, 0xFF, 0xFE, 0x38, 0x7C, 0x10, 0x00,
    0xFF, 0x3C, 0xC3, 0x03, 0x42, 0x21, 0x21, 0xDB, 0x00, 0xA5, 0xDB, 0xFE,
    0x7C, 0x38, 0x38, 0x18, 0xE7, 0x66, 0x99, 0x05, 0x42, 0x3F, 0x3F, 0x3C,
    0x00, 0x81, 0xFF, 0xFE, 0xFE, 0xFE, 0x7C, 0x3C, 0xC3, 0x42, 0xBD, 0x7D,
    0x42, 0x20, 0x21, 0xE7, 0x00, 0xBD, 0xC3, 0x7C, 0x7C, 0xFE, 0xFE, 0x3C,
    0xC3, 0x42, 0xBD, 0x84, 0x3C, 0x20, 0x23, 0xE7, 0x00, 0x99, 0xE7, 0x38,
    0x38, 0xD6, 0x7C, 0x18, 0xE7, 0x66, 0x99, 0x84, 0x18, 0x60, 0x67, 0x3C,
    0x00, 0x81, 0xFF, 0x10, 0x10, 0x10, 0x10, 0x00, 0xFF, 0x3C, 0xC3, 0x84,
    0x7E, 0xE0, 0xE6, 0xDB, 0x00, 0x7E, 0x7E, 0x00, 0x00, 0x38, 0x38, 0x00,
    0xFF, 0x00, 0xFF, 0x78, 0x18, 0xC0, 0xC0, 0x18, 0x80, 0x02, 0x18, 0x24,
    0x7F, 0x3E, 0x00, 0x18, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0xE0, 0x0E, 0x3C, 0x24, 0x92, 0x63, 0x00, 0x3C, 0x38, 0x10, 0x18, 0x30,
    0x00, 0x24, 0x10, 0xFE, 0xF8, 0x3E, 0x7E, 0x24, 0x92, 0x38, 0x00, 0x7E,
    0x7C, 0x10, 0x0C, 0x60, 0x40, 0x66, 0x38, 0xFE, 0xFE, 0xFE, 0x18, 0x24,
    0x72, 0x44, 0x00, 0x18, 0x54, 0x54, 0xFE, 0xFE, 0x40, 0xFF, 0x7C, 0x7C,
    0xF8, 0x3E, 0x18, 0x24, 0x12, 0x44, 0x7E, 0x7E, 0x10, 0x7C, 0x0C, 0x60,
    0x40, 0x66, 0xFE, 0x38, 0xE0, 0x0E, 0x7E, 0x00, 0x12, 0x38, 0x7E, 0x3C,
    0x10, 0x38, 0x18, 0x30, 0x7E, 0x24, 0xFE, 0x10, 0x80, 0x02, 0x3C, 0x24,
    0x12, 0xCC, 0x7E, 0x18, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x18, 0x00, 0x00, 0x78, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x24, 0x24, 0x18, 0x00, 0x30, 0x10,
    0x10, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x38, 0x24, 0x24,
    0x3E, 0x62, 0x48, 0x10, 0x20, 0x10, 0x44, 0x10, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x38, 0x24, 0x7E, 0x40, 0x64, 0x30, 0x20, 0x40, 0x08, 0x38, 0x10,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x10, 0x00, 0x24, 0x3C, 0x08, 0x56, 0x00,
    0x40, 0x08, 0xFE, 0x7C, 0x00, 0x7E, 0x00, 0x08, 0x00, 0x10, 0x00, 0x7E,
    0x02, 0x10, 0x88, 0x00, 0x40, 0x08, 0x38, 0x10, 0x00, 0x00, 0x00, 0x10,
    0x00, 0x00, 0x00, 0x24, 0x7C, 0x26, 0x88, 0x00, 0x20, 0x10, 0x44, 0x10,
    0x10, 0x00, 0x10, 0x20, 0x00, 0x10, 0x00, 0x24, 0x18, 0x46, 0x76, 0x00,
    0x10, 0x20, 0x00, 0x00, 0x10, 0x00, 0x10, 0x40, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
    0x3C, 0x10, 0x3C, 0x3C, 0x08, 0x7E, 0x1C, 0x7E, 0x3C, 0x3C, 0x00, 0x00,
    0x08, 0x00, 0x10, 0x3C, 0x42, 0x30, 0x42, 0x42, 0x18, 0x40, 0x20, 0x42,
    0x42, 0x42, 0x10, 0x10, 0x10, 0x00, 0x08, 0x42, 0x46, 0x50, 0x02, 0x02,
    0x28, 0x7C, 0x40, 0x04, 0x42, 0x42, 0x10, 0x10, 0x20, 0x7E, 0x04, 0x02,
    0x4A, 0x10, 0x0C, 0x1C, 0x48, 0x02, 0x7C, 0x08, 0x3C, 0x3E, 0x00, 0x00,
    0x40, 0x00, 0x02, 0x04, 0x52, 0x10, 0x30, 0x02, 0xFE, 0x02, 0x42, 0x10,
    0x42, 0x02, 0x00, 0x00, 0x20, 0x00, 0x04, 0x08, 0x62, 0x10, 0x42, 0x42,
    0x08, 0x42, 0x42, 0x10, 0x42, 0x04, 0x10, 0x10, 0x10, 0x7E, 0x08, 0x00,
    0x3C, 0x7C, 0x7E, 0x3C, 0x1C, 0x3C, 0x3C, 0x10, 0x3C, 0x38, 0x10, 0x10,
    0x08, 0x00, 0x10, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x18, 0x7C, 0x1C,
    0x78, 0x7E, 0x7E, 0x1C, 0x42, 0x38, 0x0E, 0x62, 0x70, 0x63, 0x62, 0x18,
    0x42, 0x24, 0x22, 0x22, 0x24, 0x22, 0x22, 0x22, 0x42, 0x10, 0x04, 0x24,
    0x20, 0x55, 0x52, 0x24, 0x5E, 0x42, 0x22, 0x40, 0x22, 0x28, 0x28, 0x40,
    0x42, 0x10, 0x04, 0x28, 0x20, 0x49, 0x4A, 0x42, 0x52, 0x42, 0x3C, 0x40,
    0x22, 0x38, 0x38, 0x40, 0x7E, 0x10, 0x04, 0x30, 0x20, 0x41, 0x46, 0x42,
    0x5E, 0x7E, 0x22, 0x40, 0x22, 0x28, 0x28, 0x4E, 0x42, 0x10, 0x44, 0x28,
    0x20, 0x41, 0x42, 0x42, 0x40, 0x42, 0x22, 0x22, 0x24, 0x22, 0x20, 0x22,
    0x42, 0x10, 0x44, 0x24, 0x22, 0x41, 0x42, 0x24, 0x3C, 0x42, 0x7C, 0x1C,
    0x78, 0x7E, 0x70, 0x1E, 0x42, 0x38, 0x38, 0x63, 0x7E, 0x41, 0x42, 0x18,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x7C, 0x3C, 0x7C, 0x3C, 0x7F, 0x42, 0x41, 0x41,
    0x41, 0x41, 0x7F, 0x78, 0x80, 0x78, 0x10, 0x00, 0x22, 0x42, 0x22, 0x42,
    0x49, 0x42, 0x41, 0x41, 0x22, 0x22, 0x42, 0x40, 0x40, 0x08, 0x28, 0x00,
    0x22, 0x42, 0x22, 0x40, 0x08, 0x42, 0x41, 0x41, 0x14, 0x14, 0x04, 0x40,
    0x20, 0x08, 0x44, 0x00, 0x3C, 0x42, 0x3C, 0x3C, 0x08, 0x42, 0x41, 0x49,
    0x08, 0x08, 0x08, 0x40, 0x10, 0x08, 0x82, 0x00, 0x20, 0x4A, 0x28, 0x02,
    0x08, 0x42, 0x22, 0x49, 0x14, 0x08, 0x10, 0x40, 0x08, 0x08, 0x00, 0x00,
    0x20, 0x3C, 0x24, 0x42, 0x08, 0x42, 0x14, 0x49, 0x22, 0x08, 0x21, 0x40,
    0x04, 0x08, 0x00, 0x00, 0x70, 0x03, 0x72, 0x3C, 0x1C, 0x3C, 0x08, 0x36,
    0x41, 0x1C, 0x7F, 0x78, 0x02, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
    0x10, 0x00, 0x60, 0x00, 0x06, 0x00, 0x0C, 0x00, 0x60, 0x10, 0x02, 0x60,
    0x30, 0x00, 0x00, 0x00, 0x10, 0x00, 0x20, 0x00, 0x02, 0x00, 0x12, 0x00,
    0x20, 0x00, 0x00, 0x20, 0x10, 0x00, 0x00, 0x00, 0x08, 0x3C, 0x20, 0x3C,
    0x02, 0x3C, 0x10, 0x3D, 0x2C, 0x30, 0x06, 0x24, 0x10, 0x76, 0x5C, 0x3C,
    0x00, 0x02, 0x2E, 0x42, 0x3A, 0x42, 0x38, 0x42, 0x32, 0x10, 0x02, 0x28,
    0x10, 0x49, 0x62, 0x42, 0x00, 0x3E, 0x31, 0x40, 0x46, 0x7E, 0x10, 0x42,
    0x22, 0x10, 0x02, 0x30, 0x10, 0x49, 0x42, 0x42, 0x00, 0x42, 0x31, 0x42,
    0x46, 0x40, 0x10, 0x3E, 0x22, 0x10, 0x42, 0x28, 0x10, 0x49, 0x42, 0x42,
    0x00, 0x3F, 0x2E, 0x3C, 0x3B, 0x3C, 0x38, 0x02, 0x62, 0x38, 0x42, 0x26,
    0x38, 0x49, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C,
    0x00, 0x00, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x10, 0x30, 0x32, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10,
    0x10, 0x08, 0x4C, 0x08, 0x6C, 0x36, 0x6C, 0x3E, 0x7C, 0x42, 0x41, 0x41,
    0x44, 0x42, 0x7C, 0x10, 0x10, 0x08, 0x00, 0x14, 0x32, 0x4C, 0x32, 0x40,
    0x10, 0x42, 0x41, 0x49, 0x28, 0x42, 0x08, 0x60, 0x00, 0x06, 0x00, 0x22,
    0x32, 0x4C, 0x22, 0x3C, 0x10, 0x42, 0x22, 0x49, 0x10, 0x42, 0x10, 0x10,
    0x10, 0x08, 0x00, 0x41, 0x2C, 0x34, 0x20, 0x02, 0x12, 0x46, 0x14, 0x49,
    0x28, 0x3E, 0x20, 0x10, 0x10, 0x08, 0x00, 0x41, 0x20, 0x04, 0x70, 0x7C,
    0x0C, 0x3A, 0x08, 0x36, 0x44, 0x02, 0x7C, 0x0C, 0x10, 0x30, 0x00, 0x7F,
    0x70, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x3C, 0x00, 0x0C, 0x3C, 0x42, 0x30, 0x10, 0x00,
    0x3C, 0x42, 0x30, 0x24, 0x7C, 0x30, 0x42, 0x18, 0x42, 0x44, 0x00, 0x42,
    0x00, 0x00, 0x00, 0x00, 0x42, 0x00, 0x00, 0x00, 0x82, 0x00, 0x18, 0x18,
    0x40, 0x00, 0x3C, 0x38, 0x38, 0x38, 0x38, 0x3C, 0x3C, 0x3C, 0x3C, 0x18,
    0x30, 0x18, 0x24, 0x00, 0x42, 0x44, 0x42, 0x04, 0x04, 0x04, 0x04, 0x40,
    0x42, 0x42, 0x42, 0x08, 0x10, 0x08, 0x42, 0x3C, 0x3C, 0x44, 0x7E, 0x3C,
    0x3C, 0x3C, 0x3C, 0x40, 0x7E, 0x7E, 0x7E, 0x08, 0x10, 0x08, 0x7E, 0x42,
    0x0C, 0x44, 0x40, 0x44, 0x44, 0x44, 0x44, 0x3C, 0x40, 0x40, 0x40, 0x08,
    0x10, 0x08, 0x42, 0x7E, 0x02, 0x3E, 0x3C, 0x3E, 0x3E, 0x3E, 0x3E, 0x06,
    0x3C, 0x3C, 0x3C, 0x1C, 0x38, 0x1C, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x0C, 0x00, 0x1F, 0x18, 0x00, 0x20, 0x18, 0x20, 0x00, 0x42, 0x42, 0x08,
    0x18, 0x44, 0xF8, 0x1C, 0x00, 0x00, 0x24, 0x24, 0x42, 0x10, 0x24, 0x10,
    0x42, 0x18, 0x00, 0x08, 0x24, 0x28, 0x4C, 0x12, 0x7C, 0x33, 0x44, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x24, 0x42, 0x3E, 0x20, 0x7C, 0x78, 0x10,
    0x20, 0x0C, 0x7F, 0x3C, 0x3C, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x40,
    0x70, 0x10, 0x44, 0x7C, 0x38, 0x3F, 0x44, 0x42, 0x42, 0x42, 0x42, 0x42,
    0x42, 0x42, 0x42, 0x40, 0x20, 0x7C, 0x4F, 0x10, 0x20, 0x44, 0x44, 0x42,
    0x42, 0x42, 0x42, 0x42, 0x3E, 0x24, 0x42, 0x3E, 0x42, 0x10, 0x44, 0x10,
    0x7C, 0x3B, 0x47, 0x3C, 0x3C, 0x3C, 0x3C, 0x3C, 0x02, 0x18, 0x3C, 0x08,
    0x7C, 0x10, 0x45, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x3C, 0x00, 0x00, 0x08, 0x00, 0x00, 0xE6, 0x60, 0x0C, 0x0C, 0x04, 0x00,
    0x32, 0x34, 0x3C, 0x38, 0x10, 0x00, 0x00, 0x42, 0x42, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x08, 0x04, 0x4C, 0x4C, 0x44, 0x44, 0x00, 0x00, 0x00, 0xC4,
    0xC4, 0x10, 0x12, 0x48, 0x38, 0x18, 0x00, 0x08, 0x00, 0x00, 0x44, 0x44,
    0x10, 0x00, 0x00, 0x48, 0x4A, 0x00, 0x24, 0x24, 0x04, 0x08, 0x3C, 0x42,
    0x7C, 0x62, 0x3E, 0x38, 0x20, 0x7E, 0x7E, 0xF6, 0xF6, 0x10, 0x48, 0x12,
    0x3C, 0x08, 0x42, 0x42, 0x42, 0x52, 0x00, 0x00, 0x40, 0x40, 0x02, 0x29,
    0x2A, 0x10, 0x24, 0x24, 0x44, 0x08, 0x42, 0x42, 0x42, 0x4A, 0x7E, 0x7C,
    0x42, 0x40, 0x02, 0x43, 0x5F, 0x10, 0x12, 0x48, 0x3E, 0x1C, 0x3C, 0x3C,
    0x42, 0x46, 0x00, 0x00, 0x3C, 0x00, 0x00, 0x8C, 0x82, 0x10, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F,
    0x02, 0x00, 0x00, 0x00, 0x22, 0x55, 0xDB, 0x10, 0x10, 0x10, 0x14, 0x00,
    0x00, 0x14, 0x14, 0x00, 0x14, 0x14, 0x10, 0x00, 0x88, 0xAA, 0x77, 0x10,
    0x10, 0x10, 0x14, 0x00, 0x00, 0x14, 0x14, 0x00, 0x14, 0x14, 0x10, 0x00,
    0x22, 0x55, 0xDB, 0x10, 0x10, 0xF0, 0x14, 0x00, 0xF0, 0xF4, 0x14, 0xFC,
    0xF4, 0x14, 0xF0, 0x00, 0x88, 0xAA, 0xEE, 0x10, 0x10, 0x10, 0x14, 0x00,
    0x10, 0x04, 0x14, 0x04, 0x04, 0x14, 0x10, 0x00, 0x22, 0x55, 0xDB, 0x10,
    0xF0, 0xF0, 0xF4, 0xFC, 0xF0, 0xF4, 0x14, 0xF4, 0xFC, 0xFC, 0xF0, 0xF0,
    0x88, 0xAA, 0x77, 0x10, 0x10, 0x10, 0x14, 0x14, 0x10, 0x14, 0x14, 0x14,
    0x00, 0x00, 0x00, 0x10, 0x22, 0x55, 0xDB, 0x10, 0x10, 0x10, 0x14, 0x14,
    0x10, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x10, 0x88, 0xAA, 0xEE, 0x10,
    0x10, 0x10, 0x14, 0x14, 0x10, 0x14, 0x14, 0x14, 0x00, 0x00, 0x00, 0x10,
    0x10, 0x10, 0x00, 0x10, 0x00, 0x10, 0x10, 0x14, 0x14, 0x00, 0x14, 0x00,
    0x14, 0x00, 0x14, 0x10, 0x10, 0x10, 0x00, 0x10, 0x00, 0x10, 0x10, 0x14,
    0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x14, 0x10, 0x10, 0x10, 0x00, 0x10,
    0x00, 0x10, 0x1F, 0x14, 0x17, 0x1F, 0xF7, 0xFF, 0x17, 0xFF, 0xF7, 0xFF,
    0x10, 0x10, 0x00, 0x10, 0x00, 0x10, 0x10, 0x14, 0x10, 0x10, 0x00, 0x00,
    0x10, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0x1F, 0x17,
    0x1F, 0x17, 0xFF, 0xF7, 0x17, 0xFF, 0xF7, 0xFF, 0x00, 0x00, 0x10, 0x10,
    0x00, 0x10, 0x10, 0x14, 0x00, 0x14, 0x00, 0x14, 0x14, 0x00, 0x14, 0x00,
    0x00, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10, 0x14, 0x00, 0x14, 0x00, 0x14,
    0x14, 0x00, 0x14, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x10, 0x10, 0x14,
    0x00, 0x14, 0x00, 0x14, 0x14, 0x00, 0x14, 0x00, 0x14, 0x00, 0x00, 0x14,
    0x10, 0x00, 0x00, 0x14, 0x10, 0x10, 0x00, 0xFF, 0x00, 0xF0, 0x0F, 0xFF,
    0x14, 0x00, 0x00, 0x14, 0x10, 0x00, 0x00, 0x14, 0x10, 0x10, 0x00, 0xFF,
    0x00, 0xF0, 0x0F, 0xFF, 0x14, 0xFF, 0x00, 0x14, 0x1F, 0x1F, 0x00, 0x14,
    0xFF, 0x10, 0x00, 0xFF, 0x00, 0xF0, 0x0F, 0xFF, 0x14, 0x00, 0x00, 0x14,
    0x10, 0x10, 0x00, 0x14, 0x10, 0x10, 0x00, 0xFF, 0x00, 0xF0, 0x0F, 0xFF,
    0xFF, 0xFF, 0xFF, 0x1F, 0x1F, 0x1F, 0x1F, 0xFF, 0xFF, 0xF0, 0x1F, 0xFF,
    0xFF, 0xF0, 0x0F, 0x00, 0x00, 0x10, 0x14, 0x00, 0x00, 0x10, 0x14, 0x14,
    0x10, 0x00, 0x10, 0xFF, 0xFF, 0xF0, 0x0F, 0x00, 0x00, 0x10, 0x14, 0x00,
    0x00, 0x10, 0x14, 0x14, 0x10, 0x00, 0x10, 0xFF, 0xFF, 0xF0, 0x0F, 0x00,
    0x00, 0x10, 0x14, 0x00, 0x00, 0x10, 0x14, 0x14, 0x10, 0x00, 0x10, 0xFF,
    0xFF, 0xF0, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00,
    0x7C, 0x18, 0x18, 0x1C, 0x00, 0x02, 0x0C, 0x3C, 0x00, 0x3C, 0x7E, 0x3F,
    0x42, 0x00, 0x44, 0x33, 0x10, 0x24, 0x24, 0x20, 0x62, 0x04, 0x10, 0x42,
    0x31, 0x42, 0x42, 0x54, 0x20, 0x3E, 0x44, 0x4C, 0x38, 0x42, 0x42, 0x18,
    0x95, 0x3C, 0x20, 0x42, 0x4A, 0x7C, 0x40, 0x14, 0x18, 0x48, 0x44, 0x08,
    0x44, 0x7E, 0x42, 0x3C, 0x89, 0x4A, 0x3C, 0x42, 0x44, 0x42, 0x40, 0x14,
    0x20, 0x48, 0x7A, 0x08, 0x44, 0x42, 0x24, 0x42, 0x95, 0x52, 0x20, 0x42,
    0x4A, 0x7C, 0x40, 0x14, 0x42, 0x48, 0x40, 0x08, 0x38, 0x24, 0x24, 0x42,
    0x62, 0x3C, 0x10, 0x42, 0x31, 0x40, 0x40, 0x14, 0x7E, 0x30, 0x40, 0x08,
    0x10, 0x18, 0x66, 0x3C, 0x00, 0x40, 0x0C, 0x42, 0x00, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x80, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00,
    0x00, 0x10, 0x10, 0x08, 0x0C, 0x10, 0x18, 0x00, 0x30, 0x00, 0x00, 0x0F,
    0x78, 0x30, 0x00, 0x00, 0x7E, 0x10, 0x08, 0x10, 0x12, 0x10, 0x18, 0x32,
    0x48, 0x00, 0x00, 0x08, 0x44, 0x48, 0x00, 0x00, 0x00, 0x7C, 0x04, 0x20,
    0x12, 0x10, 0x00, 0x4C, 0x48, 0x00, 0x00, 0x08, 0x44, 0x10, 0x3C, 0x00,
    0x7E, 0x10, 0x08, 0x10, 0x10, 0x10, 0x7E, 0x00, 0x30, 0x18, 0x00, 0x08,
    0x44, 0x20, 0x3C, 0x00, 0x00, 0x10, 0x10, 0x08, 0x10, 0x10, 0x00, 0x32,
    0x00, 0x18, 0x18, 0x08, 0x44, 0x78, 0x3C, 0x00, 0x7E, 0x00, 0x00, 0x00,
    0x10, 0x90, 0x18, 0x4C, 0x00, 0x00, 0x00, 0xC8, 0x00, 0x00, 0x3C, 0x00,
    0x00, 0x7C, 0x7E, 0x7E, 0x10, 0x90, 0x18, 0x00, 0x00, 0x00, 0x00, 0x28,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x60, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00,
};

uint32_t* bitmap1_to_rgba32(const unsigned char* data, int width, int height) {
    int row_bytes = (width + 7) / 8;
    uint32_t* buffer = (uint32_t*)malloc(width * height * sizeof(uint32_t));
    if (!buffer) return NULL;
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            int byte_index = y * row_bytes + (x / 8);
            int bit_index = 7 - (x % 8);
            int bit = (data[byte_index] >> bit_index) & 1;
            uint32_t color = bit ? 0xFFFFFFFF : 0x00000000; // 1: white, 0: black
            buffer[y * width + x] = color;
        }
    }
    return buffer;
}

int graphics_load_font_from_1bit_buffer(const char *buffer, int width, int height, int length_x, int length_y)
{
    if (g_font_count >= MAX_FONTS)
    {
        fprintf(stderr, "Maximum amount of fonts reached.");
        return -1;
    }

    struct Image image;
    image.data = (uint8_t*)bitmap1_to_rgba32((unsigned char*)buffer, width * length_x, height * length_y);
    image.w = width * length_x;
    image.h = height * length_y;
    image.channels = 4;
    int texture = graphics_load_texture_from_image_16bit(&image, 0, 0);
    graphics_destroy_image(&image);
    if (texture < 0)
    {
        return -1;
    }

    int font_slot = 0;
    while(g_fonts[font_slot].in_use)
    {
        font_slot++;
    }

    g_fonts[font_slot].in_use = true;
    g_fonts[font_slot].texture = texture;
    g_fonts[font_slot].width = width;
    g_fonts[font_slot].height = height;
    g_fonts[font_slot].length_x = length_x;
    g_fonts[font_slot].length_y = length_y;
    sceKernelDcacheWritebackInvalidateAll();

    return font_slot;
}

int graphics_load_small_font()
{
    return graphics_load_font_from_1bit_buffer((char*)font_small_data, FONT_SMALL_WIDTH, FONT_SMALL_HEIGHT, 16, 16);
}

int graphics_load_big_font()
{
    return graphics_load_font_from_1bit_buffer((char*)font_big_data, FONT_BIG_WIDTH, FONT_BIG_HEIGHT, 16, 16);
}

int get_closest_power_of_2(int x)
{
    if (x == 0) return 0;

    int result = 1;

    while (result < x && result != 512)
    {
        result *= 2;
    };

    return result;
}

struct Image graphics_load_image_from_archive(const char *filename)
{
    struct Image image;
    image.data = NULL;

    size_t file_size;
    char str[64];
    sprintf(str, "Loading \"%s\" from archive", filename);
    game_draw_loading_text(str, COLOR_WHITE, COLOR_BLACK);
    uint8_t *buffer = archive_load_file_entry(filename, &file_size);
    if (buffer == NULL)
    {
        DEBUG_PRINTF("Error loading image from archive entry \"%s\".\n", filename);
        sprintf(str, "Error loading \"%s\" from archive", filename);
        game_draw_loading_text(str, COLOR_TEXT_RED, COLOR_BLACK);
        return image;
    }
    image.data = stbi_load_from_memory(buffer, file_size, &image.w, &image.h, &image.channels, 4);
    g_allocated_graphic_bytes += image.w * image.h * image.channels + file_size;
    DEBUG_PRINTF("Loaded image %s with size %dx%d\n", filename, image.w, image.h);
    DEBUG_PRINTF("Allocated graphics: %d\n", g_allocated_graphic_bytes);
    free(buffer);
    g_allocated_graphic_bytes -= file_size;
    DEBUG_PRINTF("Allocated graphics: %d\n", g_allocated_graphic_bytes);

    return image;
}

struct Image graphics_load_image(const char *filename)
{
    struct Image image;

    image.data = stbi_load(filename, &image.w, &image.h, &image.channels, 4);
    if (image.data == NULL) return image;
    g_allocated_graphic_bytes += image.w * image.h * image.channels;
    DEBUG_PRINTF("Loaded image %s with size %dx%d\n", filename, image.w, image.h);
    DEBUG_PRINTF("Allocated graphics: %d\n", g_allocated_graphic_bytes);

    return image;
}

void graphics_destroy_image(struct Image *image)
{
    stbi_image_free(image->data);
    g_allocated_graphic_bytes -= image->w * image->h * image->channels;
    DEBUG_PRINTF("Allocated graphics: %d\n", g_allocated_graphic_bytes);
}

void swizzle_fast(uint8_t* out, const uint8_t* in, unsigned int width, unsigned int height);

int graphics_load_texture_from_image(struct Image *loaded_image, int start_x, int start_y)
{
    if (g_texture_count >= MAX_TEXTURES)
    {
        fprintf(stderr, "Maximum amount of textures reached.");
        return -1;
    }

    int texture_slot = 0;
    while(g_textures[texture_slot].in_use)
    {
        texture_slot++;
    }

    uint8_t *image = NULL;

    int desired_width = get_closest_power_of_2(loaded_image->w - start_x);
    int desired_height = get_closest_power_of_2(loaded_image->h - start_y);

    int real_height = (loaded_image->h - start_y) < desired_height ? (loaded_image->h - start_y) : desired_height;

    image = (uint8_t *) malloc(desired_width*desired_height*4);

    uint32_t *src = (uint32_t *)(loaded_image->data);
    uint32_t *dst = (uint32_t *)image;

    src += start_y * loaded_image->w;
    for (int j = 0; j < real_height; j++)
    {
        src += start_x;
        for (int i = 0; i < desired_width; i++)
        {
            if (i < (loaded_image->w - start_x))
            {
                *dst = *src;
                src++;
            }
            else
            {
                *dst = 0x00000000;
            }
            dst++;
        }
        if (desired_width < (loaded_image->w - start_x))
        {
            src += loaded_image->w - desired_width;
        }
    }

    uint8_t *image_swizzled = (uint8_t *) memalign(16, desired_width*desired_height*4);
    swizzle_fast(image_swizzled, image, desired_width * 4, desired_height);
    free(image);

    g_textures[texture_slot].in_use = true;
    g_textures[texture_slot].width = desired_width;
    g_textures[texture_slot].height = desired_height;
    g_textures[texture_slot].data = image_swizzled;
    g_textures[texture_slot].format = GU_PSM_8888;
    sceKernelDcacheWritebackInvalidateAll();

    g_texture_count++;

    g_allocated_graphic_bytes += desired_width * desired_height * 4;
    DEBUG_PRINTF("Allocated graphics: %d\n", g_allocated_graphic_bytes);

    return texture_slot;
}

#define RGB888_TO_RGB4444(c)    ( ( ( (c) >> 16 ) & 0x000F ) | \
      ( ( (c) >> 12 ) & 0x00F0 ) | \
      ( ( (c) >> 8 )  & 0x0F00 ) | \
      ( ( (c) >> 4 )  & 0xF000 ) )

unsigned short convert_8888_to_4444(unsigned int color_8888) {
    // Extract each 8-bit channel from the 32-bit color
    unsigned int a8 = (color_8888 & 0xFF000000) >> 24;
    unsigned int b8 = (color_8888 & 0x00FF0000) >> 16;
    unsigned int g8 = (color_8888 & 0x0000FF00) >> 8;
    unsigned int r8 = (color_8888 & 0x000000FF);

    // Convert each 8-bit channel to a 4-bit channel by taking the most significant 4 bits
    unsigned short a4 = a8 >> 4;
    unsigned short b4 = b8 >> 4;
    unsigned short g4 = g8 >> 4;
    unsigned short r4 = r8 >> 4;

    // Pack the 4-bit channels into a 16-bit color value
    unsigned short color_4444 = (a4 << 12) | (b4 << 8) | (g4 << 4) | r4;

    return color_4444;
}

int graphics_load_texture_from_image_16bit(struct Image *loaded_image, int start_x, int start_y)
{
    if (g_texture_count >= MAX_TEXTURES)
    {
        fprintf(stderr, "Maximum amount of textures reached.");
        return -1;
    }

    int texture_slot = 0;
    while(g_textures[texture_slot].in_use)
    {
        texture_slot++;
    }

    uint8_t *image = NULL;

    int desired_width = get_closest_power_of_2(loaded_image->w - start_x);
    int desired_height = get_closest_power_of_2(loaded_image->h - start_y);

    int real_height = (loaded_image->h - start_y) < desired_height ? (loaded_image->h - start_y) : desired_height;

    image = (uint8_t *) malloc(desired_width*desired_height*2);

    uint32_t *src = (uint32_t *)(loaded_image->data);
    uint16_t *dst = (uint16_t *)image;

    src += start_y * loaded_image->w;
    for (int j = 0; j < real_height; j++)
    {
        src += start_x;
        for (int i = 0; i < desired_width; i++)
        {
            if (i < (loaded_image->w - start_x))
            {
                *dst = convert_8888_to_4444(*src);
                src++;
            }
            else
            {
                *dst = 0x0000;
            }
            dst++;
        }
        if (desired_width < (loaded_image->w - start_x))
        {
            src += loaded_image->w - desired_width;
        }
    }

    uint8_t *image_swizzled = (uint8_t *) memalign(16, desired_width*desired_height*2);
    swizzle_fast(image_swizzled, image, desired_width * 2, desired_height);
    free(image);

    g_textures[texture_slot].in_use = true;
    g_textures[texture_slot].width = desired_width;
    g_textures[texture_slot].height = desired_height;
    g_textures[texture_slot].data = image_swizzled;
    g_textures[texture_slot].format = GU_PSM_4444;
    sceKernelDcacheWritebackInvalidateAll();

    g_texture_count++;

    g_allocated_graphic_bytes += desired_width * desired_height * 2;
    DEBUG_PRINTF("Allocated graphics: %d\n", g_allocated_graphic_bytes);

    return texture_slot;
}

void swizzle_fast(uint8_t* out, const uint8_t* in, unsigned int width, unsigned int height)
{
   unsigned int blockx, blocky;
   unsigned int j;

   unsigned int width_blocks = (width / 16);
   unsigned int height_blocks = (height / 8);

   unsigned int src_pitch = (width-16)/4;
   unsigned int src_row = width * 8;

   const uint8_t* ysrc = in;
   uint32_t* dst = (uint32_t*)out;

   for (blocky = 0; blocky < height_blocks; ++blocky)
   {
      const uint8_t* xsrc = ysrc;
      for (blockx = 0; blockx < width_blocks; ++blockx)
      {
         const uint32_t* src = (uint32_t*)xsrc;
         for (j = 0; j < 8; ++j)
         {
            *(dst++) = *(src++);
            *(dst++) = *(src++);
            *(dst++) = *(src++);
            *(dst++) = *(src++);
            src += src_pitch;
         }
         xsrc += 16;
     }
     ysrc += src_row;
   }
}

int graphics_load_texture_from_archive(const char *filename, int start_x, int start_y)
{
    struct Image image = graphics_load_image_from_archive(filename);
    int texture_slot = graphics_load_texture_from_image(&image, start_x, start_y);
    graphics_destroy_image(&image);
    return texture_slot;
}

int graphics_load_texture_from_archive_16bit(const char *filename, int start_x, int start_y)
{
    struct Image image = graphics_load_image_from_archive(filename);
    if (image.data == NULL)
    {
        return -1;
    }
    int texture_slot = graphics_load_texture_from_image_16bit(&image, start_x, start_y);
    if (texture_slot == -1) return -1;
    graphics_destroy_image(&image);
    return texture_slot;
}

int graphics_load_texture(const char *filename, int start_x, int start_y)
{
    struct Image image = graphics_load_image(filename);
    int texture_slot = graphics_load_texture_from_image(&image, start_x, start_y);
    graphics_destroy_image(&image);
    return texture_slot;
}

int graphics_load_texture_16bit(const char *filename, int start_x, int start_y)
{
    char str[64];
    sprintf(str, "Loading \"%s\"", filename);
    game_draw_loading_text(str, COLOR_WHITE, COLOR_BLACK);
    struct Image image = graphics_load_image(filename);
    if (image.data == NULL)
    {
        char str[64];
        sprintf(str, "Error loading \"%s\"", filename);
        game_draw_loading_text(str, COLOR_TEXT_RED, COLOR_BLACK);
        return -1;
    }
    int texture_slot = graphics_load_texture_from_image_16bit(&image, start_x, start_y);
    graphics_destroy_image(&image);
    return texture_slot;
}

int graphics_load_font(const char *filename, int width, int height, int length_x, int length_y)
{
    if (g_font_count >= MAX_FONTS)
    {
        fprintf(stderr, "Maximum amount of fonts reached.");
        return -1;
    }

    int texture = graphics_load_texture_16bit(filename, 0, 0);
    if (texture < 0)
    {
        return -1;
    }

    int font_slot = 0;
    while(g_fonts[font_slot].in_use)
    {
        font_slot++;
    }

    g_fonts[font_slot].in_use = true;
    g_fonts[font_slot].texture = texture;
    g_fonts[font_slot].width = width;
    g_fonts[font_slot].height = height;
    g_fonts[font_slot].length_x = length_x;
    g_fonts[font_slot].length_y = length_y;
    sceKernelDcacheWritebackInvalidateAll();

    return font_slot;
}

void graphics_destroy_texture(int texture)
{
    free(g_textures[texture].data);
    g_textures[texture].in_use = false;
    g_texture_count--;

    g_allocated_graphic_bytes -= g_textures[texture].width * g_textures[texture].height * 4;
    DEBUG_PRINTF("Allocated graphics: %d\n", g_allocated_graphic_bytes);
}

void graphics_destroy_font(int font)
{
    graphics_destroy_texture(g_fonts[font].texture);
    g_fonts[font].in_use = false;
    g_font_count--;
}

int g_current_set_texture = -1;
int g_current_filter = -1;

void graphics_set_no_texture()
{
    graphics_set_texture(-1, 0);
}

void graphics_set_texture(int texture, int filter)
{
    if (g_current_set_texture == texture && g_current_filter == filter) return;

    graphics_flush_quads();
    
    g_current_set_texture = texture;
    g_current_filter = filter;

    if (texture == -1)
    {
        sceGuDisable(GU_TEXTURE_2D);
    }
    else if (texture == -2)
    {
        sceGuEnable(GU_TEXTURE_2D);
        sceGuTexMode(GU_PSM_4444,0,0,GU_FALSE);
        sceGuTexImage(0, BUFFER_WIDTH, BUFFER_HEIGHT, BUFFER_WIDTH, sceGeEdramGetAddr() + (int)g_frame_buffer_2);
        sceGuTexFunc(GU_TFX_MODULATE,GU_TCC_RGB);
        sceGuTexFilter(filter,filter);
        sceGuTexScale(1.0f,1.0f);
        sceGuTexOffset(0.0f,0.0f);
    }
    else
    {
        sceGuEnable(GU_TEXTURE_2D);
        sceGuTexMode(g_textures[texture].format,0,0,GU_TRUE);
        sceGuTexImage(0, g_textures[texture].width, g_textures[texture].height, g_textures[texture].width, g_textures[texture].data);
        sceGuTexFunc(GU_TFX_MODULATE,GU_TCC_RGBA);
        sceGuTexFilter(filter,filter);
        sceGuTexScale(1.0f,1.0f);
        sceGuTexOffset(0.0f,0.0f);
    }
}

void graphics_flush_quads_end()
{
    if (g_current_quad > 0)
    {
        GU_DRAW_ARRAY_QUADS();
    }
    
    GU_FINISH();
}

void graphics_flush_quads()
{
    if (g_current_quad == 0) return;

    GU_DRAW_ARRAY_QUADS();

    // GU_FINISH();

    // GU_START();

    GU_ALLOC_QUAD_ARRAY();
}

void graphics_draw_rotated_quad(float x, float y, float w, float h, int16_t u, int16_t v, int16_t uw, int16_t vh, uint32_t color, float angle)
{
    if (angle == 0.0f)
    {
        graphics_draw_quad(x, y, w, h, u, v, uw, vh, color);
        return;
    }

    int index = 0;

    graphics_flush_quads();

    if (g_current_set_texture != -1)
    {
        int tex_width = g_textures[g_current_set_texture].width;
        int tex_height = g_textures[g_current_set_texture].height;

        u = u * INT16_MAX / tex_width;
        v = v * INT16_MAX / tex_height;
        uw = uw * INT16_MAX / tex_width;
        vh = vh * INT16_MAX / tex_height;
    }

    float w2 = w / 2.0f;
    float h2 = h / 2.0f;

    sceGumMatrixMode(GU_MODEL);
    sceGumLoadIdentity();
    ScePspFVector3 pos = { x + w2, y + h2, 0.0f };
    sceGumTranslate(&pos);
    sceGumRotateZ(angle);

    g_quad_vertices[index+0].x = -w2;       g_quad_vertices[index+0].y = -h2;   g_quad_vertices[index+0].z = 0;
    g_quad_vertices[index+0].u = u;         g_quad_vertices[index+0].v = v;
    g_quad_vertices[index+0].color = color;
    g_quad_vertices[index+1].x = w2;        g_quad_vertices[index+1].y = -h2;   g_quad_vertices[index+1].z = 0;
    g_quad_vertices[index+1].u = u + uw;    g_quad_vertices[index+1].v = v;
    g_quad_vertices[index+1].color = color;
    g_quad_vertices[index+2].x = w2;        g_quad_vertices[index+2].y = h2;    g_quad_vertices[index+2].z = 0;
    g_quad_vertices[index+2].u = u + uw;    g_quad_vertices[index+2].v = v + vh;
    g_quad_vertices[index+2].color = color;
    g_quad_vertices[index+3].x = -w2;       g_quad_vertices[index+3].y = h2;    g_quad_vertices[index+3].z = 0;
    g_quad_vertices[index+3].u = u;         g_quad_vertices[index+3].v = v + vh;
    g_quad_vertices[index+3].color = color;

    sceKernelDcacheWritebackInvalidateAll();
    sceGumDrawArray(GU_TRIANGLE_FAN, GU_COLOR_8888|GU_TEXTURE_16BIT|GU_VERTEX_32BITF|GU_TRANSFORM_3D, 4, NULL, g_quad_vertices);
    g_current_quad += 2;
    DEBUG_PRINTF("Draw Fan Triangle\n");

    sceGumMatrixMode(GU_MODEL);
    sceGumLoadIdentity();

    // GU_FINISH();

    // GU_START();

    GU_ALLOC_QUAD_ARRAY();
}

void graphics_draw_quad(float x, float y, float w, float h, int16_t u, int16_t v, int16_t uw, int16_t vh, uint32_t color)
{
    int index = g_current_quad * 2;

    if (g_current_set_texture != -1)
    {
        int tex_width = BUFFER_WIDTH;
        int tex_height = BUFFER_HEIGHT;
        if (g_current_set_texture != -2)
        {
            tex_width = g_textures[g_current_set_texture].width;
            tex_height = g_textures[g_current_set_texture].height;
        }

        u = u * INT16_MAX / tex_width;
        v = v * INT16_MAX / tex_height;
        uw = uw * INT16_MAX / tex_width;
        vh = vh * INT16_MAX / tex_height;
    }

    g_quad_vertices[index+0].x = x;     g_quad_vertices[index+0].y = y;      g_quad_vertices[index+0].z = 0;
    g_quad_vertices[index+0].u = u;     g_quad_vertices[index+0].v = v;
    g_quad_vertices[index+0].color = color;
    g_quad_vertices[index+1].x = x + w;  g_quad_vertices[index+1].y = y + h; g_quad_vertices[index+1].z = 0;
    g_quad_vertices[index+1].u = u + uw; g_quad_vertices[index+1].v = v + vh;
    g_quad_vertices[index+1].color = color;

    g_current_quad++;
    if (g_current_quad >= MAX_QUADS)
    {
        graphics_flush_quads();
    }
}

void graphics_draw_solid_quad(float x, float y, float w, float h, uint32_t color)
{
    graphics_set_no_texture();
    graphics_draw_quad(x, y, w, h, 0, 0, 0, 0, color);
}

void graphics_draw_text_center(int font, const char *text, float x, float y, float size, uint32_t color)
{
    int length = strlen(text);
    graphics_draw_text(font, text, x - ((float)length / 2.0f * g_fonts[font].width * size), y - (g_fonts[font].height * size / 2.0f), size, color);
}

void graphics_draw_text(int font, const char *text, float x, float y, float size, uint32_t color)
{
    graphics_set_texture(g_fonts[font].texture, GRAPHICS_TEXTURE_FILTER_NEAREST);

    int count = 0;
    unsigned char c = text[0];
    while (c != 0)
    {
        graphics_draw_quad(floorf(x) + (size * g_fonts[font].width) * count, floorf(y),
            (size * g_fonts[font].width), (size * g_fonts[font].height),
            ((int)c % g_fonts[font].length_x) * g_fonts[font].width, ((int)c / g_fonts[font].length_x) * g_fonts[font].height,
            g_fonts[font].width, g_fonts[font].height, color);
        c = text[++count];
    }
}

int graphics_get_formatted_text_length(const char *text, void *item)
{
    int count = 0;
    int length = 0;
    unsigned char c = text[0];
    while (c != 0)
    {
        if (c == '#')
        {
            c = text[++count];
            if (c == 0) break;
            switch(c)
            {
                case 'j':
                case 't':
                {                    
                    char str[32];
                    if (c == 'j') game_util_get_joker_hint_value((struct Joker*)item, str);
                    if (c == 't') game_util_get_tarot_hint_value((struct Tarot*)item, str);
                    char c2 = str[0];
                    int count2 = 0;
                    while (c2 != 0)
                    {
                        c2 = str[++count2];
                        length++;
                    }
                    break;
                }
            }
        }
        else
        {
            length++;
        }
        c = text[++count];
    }

    return length;
}

void graphics_draw_text_formatted_center(int font, const char *text, void *item, float x, float y, float size, uint32_t color)
{
    int length = graphics_get_formatted_text_length(text, item);
    graphics_draw_text_formatted(font, text, item, x - ((float)length / 2.0f * g_fonts[font].width * size), y - (g_fonts[font].height * size / 2.0f), size, color);
}

void graphics_draw_text_formatted(int font, const char *text, void *item, float x, float y, float size, uint32_t color)
{
    uint32_t current_color = color;
    uint32_t current_background_color = 0;

    graphics_set_texture(g_fonts[font].texture, GRAPHICS_TEXTURE_FILTER_NEAREST);

    char str[32];
    bool background_start = false;

    int count = 0;
    int length = 0;
    unsigned char c = text[0];
    while (c != 0)
    {
        if (c == '#')
        {
            c = text[++count];
            if (c == 0) break;
            switch(c)
            {
                case '0': current_color = COLOR_BLACK; break;
                case '1': current_color = COLOR_WHITE; break;
                case '2': current_color = COLOR_TEXT_RED; break;
                case '3': current_color = COLOR_TEXT_BLUE; break;
                case '4': current_color = COLOR_TEXT_GREEN; break;
                case '5': current_color = COLOR_TEXT_ORANGE; break;
                case '6': current_color = COLOR_TEXT_PURPLE; break;
                case '7': current_color = COLOR_TEXT_CYAN; break;
                case '-': current_color = color; current_background_color = 0; break;
                case 'c': background_start = true; current_background_color = COLOR_TEXT_RED; break;
                case 'd': background_start = true; current_background_color = COLOR_TEXT_PURPLE; break;
                case 'e': background_start = true; current_background_color = COLOR_TEXT_CYAN; break;
                case 'f': background_start = true; current_background_color = COLOR_TEXT_GREEN; break;
                case 'g': background_start = true; current_background_color = COLOR_TEXT_RED; break;
                case 'j':
                case 't':
                {
                    if (c == 'j') game_util_get_joker_hint_value((struct Joker*)item, str);
                    if (c == 't') game_util_get_tarot_hint_value((struct Tarot*)item, str);
                    char c2 = str[0];
                    int count2 = 0;
                    while (c2 != 0)
                    {
                        if (current_background_color != 0)
                        {
                            graphics_draw_solid_quad(floorf(x) + (size * g_fonts[font].width) * length, floorf(y),
                                (size * g_fonts[font].width), (size * g_fonts[font].height),
                                current_background_color);
                            graphics_set_texture(g_fonts[font].texture, GRAPHICS_TEXTURE_FILTER_NEAREST);
                        }
                        graphics_draw_quad(floorf(x) + (size * g_fonts[font].width) * length, floorf(y),
                            (size * g_fonts[font].width), (size * g_fonts[font].height),
                            ((int)c2 % g_fonts[font].length_x) * g_fonts[font].width, ((int)c2 / g_fonts[font].length_x) * g_fonts[font].height,
                            g_fonts[font].width, g_fonts[font].height, current_color);
                        c2 = str[++count2];
                        length++;
                    }
                    break;
                }
            }
        }
        else
        {
            if (current_background_color != 0)
            {
                graphics_draw_solid_quad(floorf(x) + (size * g_fonts[font].width) * length - (background_start ? 1.0f : 0.0f), floorf(y),
                    (size * g_fonts[font].width) + (background_start ? 1.0f : 0.0f), (size * g_fonts[font].height),
                    current_background_color);
                graphics_set_texture(g_fonts[font].texture, GRAPHICS_TEXTURE_FILTER_NEAREST);

                background_start = false;
            }
            graphics_draw_quad(floorf(x) + (size * g_fonts[font].width) * length, floorf(y),
                (size * g_fonts[font].width), (size * g_fonts[font].height),
                ((int)c % g_fonts[font].length_x) * g_fonts[font].width, ((int)c / g_fonts[font].length_x) * g_fonts[font].height,
                g_fonts[font].width, g_fonts[font].height, current_color);
            length++;            
        }
        c = text[++count];        
    }
}

void graphics_init()
{
    uint32_t vram_buffer_pos = 0;
    g_frame_buffer_0 = (void*)(vram_buffer_pos);
    vram_buffer_pos += ((unsigned int)(BUFFER_WIDTH*BUFFER_HEIGHT*4));
    g_frame_buffer_1 = (void*)(vram_buffer_pos);
    vram_buffer_pos += ((unsigned int)(BUFFER_WIDTH*BUFFER_HEIGHT*4));
    g_frame_buffer_2 = (void*)(vram_buffer_pos);

    g_last_frame_buffer = g_frame_buffer_0;

    for (int i = 0; i < MAX_TEXTURES; i++)
    {
        g_textures[i].in_use = false;
    }

    for (int i = 0; i < MAX_FONTS; i++)
    {
        g_fonts[i].in_use = false;
    }

    sceGuInit();

    GU_START();

	sceGuDrawBuffer(GU_PSM_4444, g_frame_buffer_0, BUFFER_WIDTH);
	sceGuDispBuffer(SCREEN_WIDTH, SCREEN_HEIGHT, g_frame_buffer_1, BUFFER_WIDTH);

    sceGuOffset(2048 - (SCREEN_WIDTH/2),2048 - (SCREEN_HEIGHT/2));
    sceGuViewport(2048,2048,SCREEN_WIDTH,SCREEN_HEIGHT);
	sceGuScissor(0,0,SCREEN_WIDTH,SCREEN_HEIGHT);
	sceGuEnable(GU_SCISSOR_TEST);
	sceGuFrontFace(GU_CW);
	sceGuShadeModel(GU_SMOOTH);
	sceGuDisable(GU_TEXTURE_2D);

    sceGuEnable(GU_BLEND);
	sceGuBlendFunc(GU_ADD, GU_SRC_ALPHA, GU_ONE_MINUS_SRC_ALPHA, 0, 0);

    sceGumMatrixMode(GU_PROJECTION);
    sceGumLoadIdentity();
    sceGumOrtho(0, SCREEN_WIDTH, SCREEN_HEIGHT, 0, -1, 1);

    sceGumMatrixMode(GU_VIEW);
    sceGumLoadIdentity();

    sceGumMatrixMode(GU_MODEL);
    sceGumLoadIdentity();

    GU_FINISH();

	sceDisplayWaitVblankStart();
	sceGuDisplay(GU_TRUE);
}

void graphics_begin_draw()
{
    GU_START();

    GU_ALLOC_QUAD_ARRAY();
}

void graphics_clear(uint32_t color)
{
    sceGuClearColor(color);
    sceGuClear(GU_COLOR_BUFFER_BIT);
}

void graphics_end_draw()
{
    graphics_flush_quads_end();

    sceDisplayWaitVblankStart();
	g_last_frame_buffer = sceGuSwapBuffers();
}

void graphics_clear_loading_text(uint32_t clear_color)
{
    graphics_begin_draw();
    graphics_clear(clear_color);
    graphics_end_draw();
    graphics_begin_draw();
    graphics_clear(clear_color);
    graphics_end_draw();
}

void graphics_show_loading_text(int font_tex, const char *text, float x, float y, float size, uint32_t text_color, bool clear, uint32_t clear_color)
{
    // Drawing twice in order to draw to both buffers
    graphics_begin_draw();
    if (clear) graphics_clear(clear_color);
    graphics_draw_text(font_tex, text, x, y, size, text_color);
    graphics_end_draw();

    graphics_begin_draw();
    if (clear) graphics_clear(clear_color);
    graphics_draw_text(font_tex, text, x, y, size, text_color);
    graphics_end_draw();
}

void graphics_set_offscreen_render_target()
{
    graphics_begin_draw();

    sceGuDrawBuffer(GU_PSM_4444, (void*)g_frame_buffer_2, BUFFER_WIDTH);
    sceGuOffset(2048 - (SCREEN_WIDTH/2),2048 - (256/2));
    sceGuViewport(2048,2048,SCREEN_WIDTH,256);
	sceGuScissor(0,0,SCREEN_WIDTH,SCREEN_HEIGHT);
	sceGuEnable(GU_SCISSOR_TEST);
}

void graphics_unset_offscreen_render_target()
{
    graphics_flush_quads_end();

    graphics_begin_draw();

    sceGuDrawBuffer(GU_PSM_4444, (void*)g_last_frame_buffer, BUFFER_WIDTH);
    sceGuOffset(2048 - (SCREEN_WIDTH/2),2048 - (SCREEN_HEIGHT/2));
    sceGuViewport(2048,2048,SCREEN_WIDTH,SCREEN_HEIGHT);
	sceGuScissor(0,0,SCREEN_WIDTH,SCREEN_HEIGHT);
	sceGuEnable(GU_SCISSOR_TEST);

    GU_FINISH();    
}
